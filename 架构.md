### 架构

##### MVC
模型层 (Model) ：定义属性，存储数据，并且定义如何操作这些数据。  
视图层 (View) ：负责模型层的可视化展示，并且负责用户的交互，一般来说都是继承自 UIView 这个基类。  
控制器 (Controller) ：控制器是整个系统的掌控者，它连接了模型层和数据层，并且把数据在视图层展示出来，监听各种事件，负责数据的各种操作。  

优点：代码总量少，基本上大量的逻辑和视图代码都写在了ViewController中，View和Model也做了严格的区分，代码分配遵循一定的规则，简单易上手；  
缺点：ViewController过于臃肿，里面要布局UI、更新UI、处理交互、导航等等操作都要放在ViewController里面，这样也增加了代码的耦合度，随着业务的增加代码维护难度也会越来越大；网络请求无处安放，放在Model中，其异步调用的API请求会使整个Model层变得复杂；放在ViewController里面又会使ViewController代码更加臃肿。     

##### MVCS
在MVC的基础上现在了一个S层，S的意思是Store数据存储，一般用来进行数据存储的处理，当然也可以将网络数据的请求的代码放在这层，所以称S为数据层；加入S层可以对MVC中ViewController中的部分代码进行分离，减小ViewController的代码量。  
wanjia2B项目中虽然有一个ViewModel类，实际上他的作用几乎和MVCS中的S是一样的，主要做了网络请求以及对获取到的数据的处理和存储操作。  

##### MVP Presenter展示层
Model-View/ViewController-Presenter，其中Presenter是V与M的桥接文件，Presenter会根据View的交互去修改Model，根据Model的结果去更新View；  
因为View持有Presenter所以在Presenter中的View应该声明为weak或者unowned，以避免循环引用。 
MVP的优点：相较于MVC代码的耦合度大大降低，代码分配更加合理。     
MVP的缺点：View的所有交互都要传给Presenter去处理，这样随着业务功能的增加，View和Presenter里面的代码都会同时增加，这样相较于MVC都在ViewController里面的处理方式，MVP的代码总量可能会翻翻，导致APP的维护成本和文件大小增加。  

##### MVVM
Model-View/ViewController-ViewModel 一般配合响应式框架如Objective-C中的ReactiveCocoa和Swift中的RxSwift实现。   
其中ViweModel的作用是：   
1、视图层数据的真正提供者：ViewModel对多个Model层进行包装，让View层持有ViewModel，即解偶了View和Model，也方便了View的更新；    
2、视图层的交互响应者：所有视图层的交互都会传递给ViewModel，ViewModel会依次更新View层所需要的属性，同时相应修改Model层的数据。这里通过属性观察或者响应式框架实现。  

MVVM与MVP比较相似，耦合度和代码分配都比较合理，不同点是MVP视图层需要将所有的操作和交互都传递给中间层P，且手动实现响应和更新，所以代码总量会比较大；而MVVM的响应和更新则通过响应式框架自动实现，大大减少了代码量，但是需要引入第三方框架，而且第三方框架在团队中的使用也有一定的学习成本。  

## 比较 MVC，MVP，MVVM 三种架构

* 模型层几乎相同。三种架构的模型理论来说都是数据来源，没有什么不同。
* 视图层理论上都设计为被动，但是实际上略有不同。实际开发中 MVC 中视图层与中间层高度耦合，几乎所有的操作都统一由 ViewController 包办。 但理论上来说，MVC 是希望视图层就是单纯的 UIView，或者 UIViewController 只负责 UI 更新交互，不涉及业务逻辑和模型更新。 MVP 和 MVVM 在实际开发中视图层实现了 MVC 理论期望，即与中间层严格分离。 MVP 中视图层是完全被动，单纯的把交互和更新传递给中间层；而 MVVM 中视图层并不是完全被动——它会监视中间层的变化，一旦产生变化，则视图层也会相应变化。
* 中间层的设计是三种架构的核心的差异。逻辑上讲，中间层的作用就是连接视图层和模型层。它处理交互、接受通知、完成数据更新。 MVC 的中间层 Controller 持有视图和模型，主要起到一个组装和连接的作用，通过传递参数和实例变量来直接完成所有操作。 MVP 的中间层 Presenter 持有模型，在更新模型上与 MVC 的 Controller 角色一样。但它不拥有视图，视图拥有中间层，中间层的工作流程是：从视图层接收交互传递->响应->向视图层传递响应指令->视图进行更新。全部操作必须手动书写代码完成。 MVVM 的中间层 View Model 持有模型，在更新模型上与前两者相同。它完全独立于视图，视图拥有中间层，通过绑定属性，自动进行更新。全部操作由响应式逻辑框架自动完成。
* MVC 耦合度很高，代码分配最不合理，维护和扩展成本最高。但因为无需层级传递，所以代码总量最少，适合初学者理解和应用。
* MVP 和 MVVM 相似，耦合度和代码分配都比较合理，较易实现高测试覆盖率。MVP 的缺点是视图层需要将所有的交互传递给中间层，且要手动实现响应和更新，所以总代码量远超 MVVM。MVVM 在响应和更新上通过响应式框架自动操作，大大精简了代码量；但是需要引入第三方响应式框架，同时因为属性观察环环相扣，调用栈很大，debug 起来尤为痛苦。
* MVC，MVP，MVVM 这三种结构都是以视图为驱动的架构，三种皆为用户交互和视图更新为主要服务目标。它们一个共同的缺点是没有涉及界面之间的跳转——即路由的设计。

