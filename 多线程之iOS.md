参考资料：  
[iOS多线程编程总结](https://bestswifter.com/multithreadconclusion/)  
[iOS多线程详解](http://www.imlifengfeng.com/blog/?p=533)  
[使用GCD](https://blog.devtang.com/2012/02/22/use-gcd/)  
[iOS 並行程式設計: 初探 NSOperation 和 Dispatch Queues](https://www.appcoda.com.tw/ios-concurrency/)  
[iOS多线程：GCD详解](https://juejin.im/post/6844904093488513037#heading-0)  
[iOS多线程之GCD详解](https://juejin.im/post/6844903529522397198#heading-13)

为什么要使用多线程？  
充分利用现有的资源（CPU），提升App的运行性能，保证App实时响应用户操作。  
主线程一般用于负责UI相关操作，如绘制图层、布局、响应用户交互等操作，很多UI操作如果不放在主线程中操作会出现未知的效果（可能没反应），并且Xcode会直接将在非主线程的UI操作打印到控制台。  
其他线程，如后台线程一般用来处理耗时操作如：网络请求、数据解析、负责计算、图片的编码解码等，如果将这些耗时操作放到主线程，由于主线程是串行队列，所以会直接影响主线程的UI操作，影响用户体验。

### 三种多线程技术比较

1、NSThread  
优点：NSThread 比其他两个轻量级，使用简单；  
缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。线程同步对数据的加锁会有一定的系统开销。

2、GCD \(Grand Central Dispatch 大中心派发\)  
GCD 是iOS 4.0以后才出现的并发技术

将线程管理推给了系统，使用名为dispatch queue的队列，开发者只需要定义每个线程需要执行的操作即可。所有的工作都是先进先出。使用场景主要是比较耗时的操作如：图片异步加载、网络请求等。

使用方式：将任务添加到队列（串行/并行（全局）），指定执行任务的方法（同步（阻塞）/异步 ）  
拿到主队列：OC `dispatch_get_main_queue()`, Swift `DispatchQueue.main`  
NSOperation无法做到的：1.一次性执行 2.延迟执行 3.调度组（op实现要复杂的多 ）

3、NSOperation  
NSOperation iOS2.0的时候就出现了（当时不好用，后来苹果对其进行改造）

虽然是OperationQueue队列实现，但却不限于先进先出的队列操作。

使用方式：将操作（异步执行）添加到队列（并发/全局）  
拿到主队列：\[NSOperationQueue mainQueue\] 主队列，任务添加到主队列就会在主线程执行  
提供了GCD不好实现的：1.最大并发数 2.暂停和继续 3.取消所有任务 4.依赖关系

### GCD

Grand Central Dispatch \(GCD\) 是 Apple 开发的一个多核编程的解决方法。  
GCD 能够极大地方便开发者进行多线程编程。

** GCD的使用核心 **

确定任务在哪个线程中，以什么样的顺序执行。

将要执行的任务/代码用block封装好，添加到合适的**队列**，并设置合适的**执行方式**。队列.执行方式.block。

##### GCD中队列和执行方式是同时出现的两个重要“参数”

##### 队列

队列：是一种数据结构，它以先进先出\(FIFO\)的方式来管理存储的对象。

* serial Queue串行队列：当前队列中同一时间只能执行一个任务，前一个任务执行完才能执行下一个任务，在串行中只有一个线程；串行队列的任务一定是按开始的顺序结束。  
* concurrent Queue并发队列：同一时间可以有多个任务同时执行，在并发队列中可以有多个线程；并发队列只能保证任务一开始的顺序是它们加入队列的顺序，它们执行时都是并行的，不能保证它们的执行时间和执行结束完成时间，任务的执行由系统决定。

##### 执行方式

* sync 同步：没有开线程的能力；同步会把当前任务加入到队列中，当任务执行完之后，线程才会继续执行，也就是说同步会阻塞线程。  
* async 异步：有开线程的能力，根据具体队列决定是否开线程；异步会把当前的任务加入到队列中，但它会立刻返回，无需等待任务执行完成，也就是说异步不会阻塞当前线程。  

派发给串行队列和并行队列的异步任务都是在另外一个线程中执行的，即与创建队列的线程不同的线程。

| 队列 / 执行方式 | 同步 | 异步 | 备注 |
| :---: | :---: | :---: | --- |
| 串行队列 | 当前线程顺序执行 | 一个新线程顺序执行 | 注意在串行队列中执行同步操作容易造成死锁，在并行队列中无需担心 |
| 并发队列 | 当前线程顺序执行 | 一个或多个新线程无序执行 | 同全局队列的区别：&lt;/br&gt;并行队列有名称，在MRC下需要调用`dispatch_release`进行释放; &lt;/br&gt;`dispatch_barrier`必须使用自定义的并发队列：开发第三方框架建议使用并发队列。 |
| 全局队列 | 当前线程顺序执行 | 新线程无序执行 | 同并发队列的区别：&lt;/br&gt;全局队列没有名称，无论是ARC还是MRC都不需要考虑内存释放，日常开发中建议使用。 |
| 主队列 | 在主线程中向主队列中添加同步任务，会造成线程死锁；&lt;/br&gt;在其他线程中向主队列中添加同步任务，会在主线程中顺序执行 | 主线程顺序执行 |  |

##### 死锁

上面提到在主线程中，向主队列中同步派发一个任务，就会造成死锁；实际上，只要向当前串行队列中同步派发一个任务，都会造成死锁。

```
// eg: 1
override func viewDidLoad() {
    super.viewDidLoad()
    // 已经在主队列中，再向主队列中同步派发一个任务，造成死锁
    DispatchQueue.main.sync {
        print("123")
    }
}
// eg: 2
override func viewDidLoad() {
    super.viewDidLoad()
    let serialQueue = DispatchQueue(label: "aSerialQueue")
    serialQueue.async { // 这里无论是同步还是异步，其里面包裹的代码都是在serialQueue队列里同步执行
        // 任务 1
        // 片段1
        print("1")
        // 已经在串行队列serialQueue里，再向串行队列serialQueue中添加同步任务，就会造成死锁
        // 片段2 sync表示同步的执行任务，也就是说执行sync后当前队列会阻塞
        serialQueue.sync {
            // 任务 2
            print("2")
        }
    }
}
同一队列的一个一个block块就相当于一个任务，serialQueue队列现在有两个任务；   

任务1执行完成就需要片段2执行完成，片段2要执行完成的就需要任务2执行完成，而任务2执行完成就必须等任务1执行完成，即需要片段2执行了完成，这就形成可相互等待，导致死锁。
```

### NSOperation

与GCD不同，Operation队列不需要遵从先进先出的原则，两者的不同之处：

1. 不遵从先进先出的原则：在Operation中，你可以为任务设定执行的优先级并为任务之间添加依赖性。也就是说你可以让一些任务在其他任务执行完之后再执行。这就是它们不需要遵从先进先出原则的原因。 
2. 默认以并行的方式执行，你无法让任务以串行的方式执行，当然，可以通过设置任务之间的依赖方式，让Operation以某种顺序执行任务。  

提交给Operation队列中的任务必须封装在NSOperation对象中。

`NSOperation`封装了需要执行的操作和执行操作所需要的数据，可以以并发或者非并发的方式执行操作，`NSOperation`本身是抽象基类，所以只能使用它的子类。

系统给我们提供了两个`NSOperation`的子类：  
`NSBlockOperation`： 以block的方式创建操作，可以包含多个block，只有当所有的block都执行完成才视做该任务完成；  
`NSInvocationOperation`： 这个类创建出的NSOperation用于执行指定对象的选择器\(selector\)。  
当然我们也可以自定义。

自定义`NSOperation`的子类时需要注意：

* 自定义非并发的`NSOperation`，只需要实现两个方法：自定义初始化方法和main方法。

* 自定义并发的`NSOperation`有一些必须实现的方法和属性：

  | 方法／属性 | 描述 |
  | :---: | --- |
  | start | 必须的，所有并发执行的`operation`都必须要重写这个方法，替换掉`NSOperation`类中的默认实现。`start`方法是一个`operation`的起点，我们可以在这里配置任务执行的线程或者一些其它的执行环境。另外，需要特别注意的是，在我们重写的`start`方法中一定不要调用父类的实现`[super start]`。 |
  | main | 可选的，通常这个方法就是专门用来实现与该`operation`相关联的任务的。尽管我们可以直接在`start`方法中执行我们的任务，但是用`main`方法来实现我们的任务可以使设置代码和任务代码得到分离，从而使`operation`的结构更清晰； |
  | isExecuting 和 isFinish | 必须的，并发执行的 operation 需要负责配置它们的执行环境，并且向外界客户报告执行环境的状态。因此，一个并发执行的 operation 必须要维护一些状态信息，用来记录它的任务是否正在执行，是否已经完成执行等。此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 KVO 通知，以便外界能够观察到这些状态的变化。 |
  | isConcurrent | 必须的，这个方法的返回值用来标识一个`operation`是否是并发的 `operation`，我们需要重写这个方法并返回`YES`。 |

#### NSOperation的使用：

1. 执行操作：`NSOperation`调用`-(void)start`方法即可开始执行操作，默认按同步方式执行，即在调用`start`方法所在的线程中执行。`NSOperation`的`-(Bool)isConcurrent`方法会返回当前操作相对于调用start方法的线程是同步还是异步执行。默认返回NO，异步执行。
2. 取消操作：`NSOperation`开始执行操作之后默认会一直执行操作直到完成，可以调用`-(void)cancel`方法中途取消操作。需要注意的是，调用`cancel`方法后并不是立即取消的，而是在下一个`isCancelled`的检查点取消的。
3. 执行完成：如果想在`NSOperation`执行操作完成之后做一些处理，可以调用`setCompletionBlock`方法来在`block`中处理。



